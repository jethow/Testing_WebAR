<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Multi-Face 3D Hat Filter</title>

<!-- Import Map for Three.js modules -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/"
  }
}
</script>

<style>
  body { margin:0; overflow:hidden; background:#000; }
  video, canvas {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scaleX(-1); /* mirror */
    object-fit: none; /* preserve native aspect ratio */
    width: auto;
    height: auto;
  }
</style>
</head>
<body>
<video id="video" autoplay playsinline muted></video>

<script type="module">
  import * as THREE from "three";
  import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
  import { FaceMesh } from "https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js";
  import { Camera } from "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js";

  const video = document.getElementById("video");

  // ===== Three.js setup =====
  const scene = new THREE.Scene();
  const camera3D = new THREE.PerspectiveCamera(45,1,0.1,1000);
  camera3D.position.z = 5;

  const renderer = new THREE.WebGLRenderer({ alpha:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // ===== Load Hats =====
  const MAX_HATS = 5;
  const hats = [];
  const loader = new GLTFLoader();
  loader.load("hat.glb", (gltf)=>{
    for(let i=0;i<MAX_HATS;i++){
      const hat = gltf.scene.clone();
      hat.visible=false;
      scene.add(hat);
      hats.push(hat);
    }
  });

  // ===== FaceMesh =====
  const faceMesh = new FaceMesh({
    locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
  });

  faceMesh.setOptions({
    maxNumFaces: MAX_HATS,
    refineLandmarks:true,
    minDetectionConfidence:0.5,
    minTrackingConfidence:0.5
  });

  faceMesh.onResults(results => {
    if(!results.multiFaceLandmarks){
      hats.forEach(h=>h.visible=false);
      return;
    }

    hats.forEach(h=>h.visible=false);

    results.multiFaceLandmarks.forEach((landmarks,index)=>{
      if(index>=hats.length) return;

      const hat = hats[index];
      hat.visible=true;

      const leftEye = landmarks[33];
      const rightEye = landmarks[263];
      const forehead = landmarks[10];

      const x = 0.5 - (leftEye.x + rightEye.x)/2; // flip X
      const y = -(forehead.y - 0.5);

      hat.position.set(x*6, y*4+0.2,0);

      const faceWidth = Math.abs(rightEye.x - leftEye.x);
      hat.scale.set(faceWidth*4, faceWidth*4, faceWidth*4);
    });
  });

  // ===== Start camera =====
  try{
    const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:"user" } });
    video.srcObject = stream;

    video.onloadedmetadata = ()=>{
      video.play();

      const cameraMP = new Camera(video,{
        onFrame: async()=>{ await faceMesh.send({image:video}); },
        width: video.videoWidth,
        height: video.videoHeight,
        facingMode:"user"
      });
      cameraMP.start();

      resizeHandler();
    };
  }catch(e){ console.error("Camera error:", e); }

  // ===== Animation loop =====
  function animate(){
    requestAnimationFrame(animate);
    renderer.render(scene,camera3D);
  }
  animate();

  // ===== Resize =====
  function resizeHandler(){
    if(!video.videoWidth) return;

    const videoAspect = video.videoWidth/video.videoHeight;
    const windowAspect = window.innerWidth/window.innerHeight;
    let width,height;

    if(windowAspect>videoAspect){
      height = window.innerHeight;
      width = height*videoAspect;
    } else {
      width = window.innerWidth;
      height = width/videoAspect;
    }

    video.style.width = width + "px";
    video.style.height = height + "px";

    renderer.setSize(width,height);
    camera3D.aspect = width/height;
    camera3D.updateProjectionMatrix();
  }

  window.addEventListener("resize", resizeHandler);
</script>
</body>
</html>
