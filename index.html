<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multi-Face 3D Hat Filter</title>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/"
    }
  }
  </script>

  <style>
    body { margin: 0; overflow: hidden; }
    video {
      position: absolute;
      top: 0;
      left: 0;
      transform: scaleX(-1);
      display: none; /* hide the video */
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }
  </style>
</head>
<body>
<video id="video" autoplay playsinline muted></video>

<script type="module">
import * as THREE from "three";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
import { FaceMesh } from "https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js";
import { Camera } from "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js";

const video = document.getElementById("video");

// ===== Three.js Setup =====
const scene = new THREE.Scene();
const camera3D = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
camera3D.position.z = 5;
const renderer = new THREE.WebGLRenderer({ alpha: true });
document.body.appendChild(renderer.domElement);

// ===== Load Hats =====
const MAX_HATS = 5;
const hats = [];
const loader = new GLTFLoader();
loader.load("hat.glb", gltf => {
  for (let i = 0; i < MAX_HATS; i++) {
    const hat = gltf.scene.clone();
    hat.visible = false;
    scene.add(hat);
    hats.push(hat);
  }
});

// ===== MediaPipe FaceMesh =====
const faceMesh = new FaceMesh({
  locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
});
faceMesh.setOptions({
  maxNumFaces: MAX_HATS,
  refineLandmarks: true,
  minDetectionConfidence: 0.5,
  minTrackingConfidence: 0.5
});

faceMesh.onResults(results => {
  if (!results.multiFaceLandmarks) {
    hats.forEach(h => h.visible = false);
    return;
  }

  hats.forEach(h => h.visible = false);

  results.multiFaceLandmarks.forEach((landmarks, i) => {
    if (i >= hats.length) return;
    const hat = hats[i];
    hat.visible = true;

    const leftEye = landmarks[33];
    const rightEye = landmarks[263];
    const forehead = landmarks[10];

    // Normalized coordinates [0,1] â†’ Three.js coordinates
    // Mirror X because video is mirrored
    const x = -( (leftEye.x + rightEye.x) / 2 - 0.5 ) * video.videoWidth / 200;
    const y = -( forehead.y - 0.5 ) * video.videoHeight / 200;
    const faceWidth = Math.abs(rightEye.x - leftEye.x) * video.videoWidth / 100;

    hat.position.set(x, y + 0.8, 0);
    hat.scale.set(faceWidth, faceWidth, faceWidth);
  });
});

// ===== Start Camera =====
const cameraMP = new Camera(video, {
  onFrame: async () => await faceMesh.send({ image: video }),
  width: 640,
  height: 480
});
cameraMP.start();

// ===== Wait for video to load to set renderer size =====
video.addEventListener("loadedmetadata", () => {
  renderer.setSize(video.videoWidth, video.videoHeight);
  camera3D.aspect = video.videoWidth / video.videoHeight;
  camera3D.updateProjectionMatrix();
});

// ===== Animation Loop =====
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera3D);
}
animate();

// ===== Handle window resize =====
window.addEventListener("resize", () => {
  if (video.videoWidth && video.videoHeight) {
    renderer.setSize(video.videoWidth, video.videoHeight);
    camera3D.aspect = video.videoWidth / video.videoHeight;
    camera3D.updateProjectionMatrix();
  }
});
</script>
</body>
</html>
