<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multi-Face 3D Hat Filter</title>

  <!-- Import Map for Three.js -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/"
    }
  }
  </script>

  <style>
    body { margin: 0; overflow: hidden; }
    video {
      position: absolute;
      top: 0;
      left: 0;
      transform: scaleX(-1);
      display: none; /* Hide the video if you only want the overlay */
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }
  </style>
</head>

<body>
<video id="video" autoplay playsinline muted></video>

<script type="module">
  import * as THREE from "three";
  import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";

  const video = document.getElementById("video");

  // ===== Initialize Three.js =====
  const scene = new THREE.Scene();
  const camera3D = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
  camera3D.position.z = 5;

  const renderer = new THREE.WebGLRenderer({ alpha: true });
  document.body.appendChild(renderer.domElement);

  const MAX_HATS = 5;
  const hats = [];

  // ===== Load Hat Model =====
  const loader = new GLTFLoader();
  loader.load("hat.glb", (gltf) => {
    for (let i = 0; i < MAX_HATS; i++) {
      const hat = gltf.scene.clone();
      hat.visible = false;
      scene.add(hat);
      hats.push(hat);
    }
  });

  // ===== MediaPipe FaceMesh =====
  import { FaceMesh } from "https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js";
  import { Camera } from "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js";

  const faceMesh = new FaceMesh({
    locateFile: (file) =>
      `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
  });

  faceMesh.setOptions({
    maxNumFaces: MAX_HATS,
    refineLandmarks: true,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });

  faceMesh.onResults(results => {
    if (!results.multiFaceLandmarks) {
      hats.forEach(h => h.visible = false);
      return;
    }
    hats.forEach(h => h.visible = false);

    results.multiFaceLandmarks.forEach((landmarks, index) => {
      if (index >= hats.length) return;
      const hat = hats[index];
      hat.visible = true;

      // Compute center between eyes + forehead
      const leftEye = landmarks[33];
      const rightEye = landmarks[263];
      const topForehead = landmarks[10];

      const x = (leftEye.x + rightEye.x) / 2 - 0.5;
      const y = -(topForehead.y - 0.5);

      // Scale positions to video resolution
      const videoWidth = video.videoWidth;
      const videoHeight = video.videoHeight;

      hat.position.set(x * videoWidth / 200, y * videoHeight / 200 + 0.8, 0);

      const faceWidth = Math.abs(rightEye.x - leftEye.x);
      hat.scale.set(faceWidth * videoWidth / 100, faceWidth * videoWidth / 100, faceWidth * videoWidth / 100);
    });
  });

  // ===== Camera Setup =====
  const cameraMP = new Camera(video, {
    onFrame: async () => { await faceMesh.send({ image: video }); },
    width: 640,
    height: 480
  });

  cameraMP.start();

  // ===== Adjust Renderer to Match Video Resolution =====
  video.addEventListener('loadedmetadata', () => {
    renderer.setSize(video.videoWidth, video.videoHeight);
    camera3D.aspect = video.videoWidth / video.videoHeight;
    camera3D.updateProjectionMatrix();
  });

  // ===== Animation Loop =====
  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera3D);
  }
  animate();

  // ===== Handle Window Resize =====
  window.addEventListener("resize", () => {
    if (video.videoWidth && video.videoHeight) {
      renderer.setSize(video.videoWidth, video.videoHeight);
      camera3D.aspect = video.videoWidth / video.videoHeight;
      camera3D.updateProjectionMatrix();
    }
  });
</script>
</body>
</html>
